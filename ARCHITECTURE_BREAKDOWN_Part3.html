<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic-Tac-Toe Server Architecture - Part 3</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.95;
        }
        
        .content {
            padding: 40px;
        }
        
        h2 {
            color: #667eea;
            margin: 30px 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 3px solid #667eea;
            font-size: 1.8em;
        }
        
        h3 {
            color: #764ba2;
            margin: 20px 0 10px 0;
            font-size: 1.3em;
        }
        
        h4 {
            color: #667eea;
            margin: 15px 0 8px 0;
            font-size: 1.1em;
        }
        
        p {
            margin: 15px 0;
            line-height: 1.8;
            color: #555;
        }
        
        .highlight-box {
            background: #f0f4ff;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        
        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.4;
        }
        
        .code-block code {
            display: block;
            white-space: pre;
        }
        
        .diagram {
            background: #f5f5f5;
            border: 2px solid #ddd;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            line-height: 1.3;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        
        table th {
            background: #667eea;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: bold;
        }
        
        table td {
            padding: 12px;
            border-bottom: 1px solid #ddd;
        }
        
        table tr:hover {
            background: #f9f9f9;
        }
        
        table tr:nth-child(even) {
            background: #f5f5f5;
        }
        
        .nav-section {
            background: #f9f9f9;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        
        .nav-section h3 {
            margin-top: 0;
        }
        
        .nav-links {
            list-style: none;
        }
        
        .nav-links li {
            margin: 8px 0;
        }
        
        .nav-links a {
            color: #667eea;
            text-decoration: none;
            font-weight: 500;
        }
        
        .nav-links a:hover {
            text-decoration: underline;
            color: #764ba2;
        }
        
        .footer {
            background: #f9f9f9;
            padding: 20px;
            text-align: center;
            border-top: 2px solid #ddd;
            color: #777;
            margin-top: 30px;
        }
        
        .part-indicator {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            margin-bottom: 20px;
            font-weight: bold;
        }
        
        ul, ol {
            margin: 15px 0 15px 30px;
        }
        
        li {
            margin: 8px 0;
        }
        
        .section-box {
            background: #fff9e6;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéÆ Tic-Tac-Toe Server Architecture</h1>
            <p>Senior Bachelor Level Technical Breakdown</p>
            <div class="part-indicator">PART 3 - TttRoom, Communication Flows & Threading</div>
        </div>
        
        <div class="content">
            
            <div class="nav-section">
                <h3>üìë Documentation Parts</h3>
                <ul class="nav-links">
                    <li><a href="ARCHITECTURE_BREAKDOWN_Part1.html">‚Üê Part 1</a></li>
                    <li><a href="ARCHITECTURE_BREAKDOWN_Part2.html">‚Üê Part 2</a></li>
                    <li><strong>Part 3 (Current)</strong> - TttRoom, Communication Flows & Threading</li>
                    <li><a href="ARCHITECTURE_BREAKDOWN_Part4.html">Part 4 ‚Üí</a></li>
                    <li><a href="ARCHITECTURE_BREAKDOWN_Part5.html">Part 5</a></li>
                </ul>
            </div>
            
            <!-- ===== TTTROOM & MATCHMAKER ===== -->
            <h2>2.8 TttRoom & Matchmaker - Game Room Management</h2>
            
            <p><strong>Purpose:</strong> Manages active game rooms and routes messages to appropriate games.</p>
            
            <h3>TttRoom Design - Efficient Game State Representation</h3>
            
            <div class="code-block"><code>public class TttRoom {
    private int xMask = 0;      // Bitmask of X positions
    private int oMask = 0;      // Bitmask of O positions
    private boolean xTurn = true; // Whose turn?
    
    // Example: X at positions 0,4,8; O at positions 1,2
    // xMask = 0b100010001 (binary) = positions where X played
    // oMask = 0b011000000 (binary) = positions where O played
}</code></div>
            
            <h3>Why Bitmasks Instead of Strings?</h3>
            
            <table>
                <tr>
                    <th>Metric</th>
                    <th>Bitmask Approach</th>
                    <th>String Approach</th>
                </tr>
                <tr>
                    <td><strong>Performance</strong></td>
                    <td>Integer AND/OR: 1 CPU cycle</td>
                    <td>String manipulation: 100+ cycles</td>
                </tr>
                <tr>
                    <td><strong>Memory</strong></td>
                    <td>2 integers = 8 bytes</td>
                    <td>String "....X.O.." = 36 bytes</td>
                </tr>
                <tr>
                    <td><strong>Win Detection</strong></td>
                    <td>Bitwise comparison: ultra-fast</td>
                    <td>Character iteration: slower</td>
                </tr>
                <tr>
                    <td><strong>Occupied Check</strong></td>
                    <td><code>if ((xMask | oMask) & bit) != 0</code></td>
                    <td>String search or array iteration</td>
                </tr>
            </table>
            
            <h3>Win Patterns Using Bitmasks</h3>
            
            <div class="code-block"><code>private static final int[] WINS = {
    0b111000000,  // Row 1 (positions 0,1,2)
    0b000111000,  // Row 2 (positions 3,4,5)
    0b000000111,  // Row 3 (positions 6,7,8)
    0b100100100,  // Col 1 (positions 0,3,6)
    0b010010010,  // Col 2 (positions 1,4,7)
    0b001001001,  // Col 3 (positions 2,5,8)
    0b100010001,  // Diagonal \ (positions 0,4,8)
    0b001010100   // Diagonal / (positions 2,4,6)
};

Win Detection:
for (int winPattern : WINS) {
    if ((xMask & winPattern) == winPattern) {
        return "X_wins";  // X has all 3 in this pattern
    }
}</code></div>
            
            <div class="section-box">
                <strong>Binary Visualization:</strong>
                <div class="code-block"><code>Board positions:
    0 1 2
    3 4 5
    6 7 8

Row 1 win (0,1,2):
    X X X       111000000 (binary) = 0xE0
    . . .    ‚Üí  000000000
    . . .       000000000

Bit 8 7 6 5 4 3 2 1 0
    1 1 1 0 0 0 0 0 0 = positions 0,1,2</code></div>
            </div>
            
            <h3>Move Validation</h3>
            
            <div class="code-block"><code>public void onMove(ClientSession s, int cell) {
    sched.execute(() -> {
        // 1. Check if correct player's turn
        boolean isX = (s == p1);
        if (xTurn != isX) return; // Invalid: not your turn
        
        // 2. Check if cell is empty
        int bit = 1 << (8 - cell);
        if (((xMask | oMask) & bit) != 0) return; // Invalid: occupied
        
        // 3. Make move
        if (isX) xMask |= bit;    // Set X bit
        else oMask |= bit;        // Set O bit
        xTurn = !xTurn;           // Switch turns
        
        // 4. Check for end condition
        String result = result();
        if (!"ongoing".equals(result)) {
            broadcastOver(result); // Game ends
        } else {
            broadcastState(result); // Continue playing
        }
    });
}</code></div>
            
            <p><strong>Bitwise Operation Explanation:</strong></p>
            <ul>
                <li><code>1 << (8 - cell)</code> creates a bitmask with a single bit set at position (8-cell)</li>
                <li><code>(xMask | oMask) & bit</code> checks if ANY player has played at this position</li>
                <li><code>xMask |= bit</code> sets the bit for X's position (bitwise OR assignment)</li>
            </ul>
            
            <h3>Forfeit Timer</h3>
            
            <div class="code-block"><code>private void scheduleTimer() {
    // 120-second inactivity timeout
    timer = sched.schedule(() -> {
        String winner = xTurn ? "O" : "X"; // Whoever's turn it is forfeits
        broadcastOver("forfeit:" + winner);
    }, 120, TimeUnit.SECONDS);
}

Why 120 seconds?
‚Ä¢ Prevents games from hanging forever if a player's internet drops
‚Ä¢ Reasonable timeout for human player (not too aggressive)
‚Ä¢ Long enough to handle network hiccups</code></div>
            
            <h3>Matchmaker Pattern</h3>
            
            <div class="code-block"><code>public void requestJoin(ClientSession s, String game) {
    ClientSession other = tttWait.poll(); // Try to get waiting player
    
    if (other == null) {
        tttWait.add(s);  // You're first, wait
        s.send({"t": "waiting"});
    } else {
        // Found opponent! Create room
        String id = "M-" + UUID.randomUUID();
        TttRoom room = new TttRoom(id, sched);
        rooms.put(id, room);
        room.addPlayer(other, 1);  // Existing player is X
        room.addPlayer(s, 2);      // New player is O
        room.start();
    }
}</code></div>
            
            <!-- ===== COMMUNICATION FLOWS ===== -->
            <h2>3. Communication Flow: Request ‚Üí Response</h2>
            
            <h3>3.1 Join Game Flow</h3>
            
            <div class="diagram">
STEP 1: Client initiates join
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Defold Game Client     ‚îÇ
‚îÇ  net.join(sessionId, name)
‚îÇ  Sends HTTP POST        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ POST /api/join
             ‚îÇ {"sessionId": "uuid-123", "name": "Swift Gamer"}
             ‚ñº
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ RestApiServer     ‚îÇ
         ‚îÇ POST /api/join    ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
                  ‚ñº
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ GameService         ‚îÇ
         ‚îÇ .joinGame()         ‚îÇ
         ‚îÇ (async/executor)    ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
        LOBBY STATE CHECK
                  ‚îÇ
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ                  ‚îÇ
    [FIRST PLAYER]   [SECOND PLAYER]
         ‚îÇ                  ‚îÇ
    Acquire lobbyLock       ‚îÇ
         ‚îÇ              Acquire lobbyLock
         ‚îÇ                  ‚îÇ
    waitingPlayerId=null ‚Üí Sees waitingPlayerId set
         ‚îÇ                  ‚îÇ
    Set waitingPlayerId     ‚îÇ
    Return "waiting"    Create matchId
         ‚îÇ                  ‚îÇ
         ‚îÇ              Clear waitingPlayerId
         ‚îÇ              createGame() ‚Üí GameStateCache
         ‚îÇ              Return matchId
         ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ                                 ‚îÇ
    ‚ñº                                 ‚ñº
HTTP Response                    HTTP Response
{"matchId": "waiting"}          {"matchId": "M-uuid-abc"}
    ‚îÇ                                 ‚îÇ
    ‚ñº                                 ‚ñº
Client waits...              Client receives matchId
                            
STEP 2: Server notifies both players via WebSocket
                            
    GameService calls:
    wsNotifier.notifyMatchStart(matchId)
        ‚îÇ
        ‚îú‚îÄ‚Üí Query database for player1_session, player2_session
        ‚îÇ
        ‚îú‚îÄ‚Üí Send Player 1:
        ‚îÇ   {"t": "match_start",
        ‚îÇ    "matchId": "M-uuid-abc",
        ‚îÇ    "yourMark": "X",
        ‚îÇ    "opponentMark": "O"}
        ‚îÇ
        ‚îî‚îÄ‚Üí Send Player 2:
            {"t": "match_start",
             "matchId": "M-uuid-abc",
             "yourMark": "O",
             "opponentMark": "X"}
    
Both clients receive match_start and update UI.
            </div>
            
            <h3>3.2 Make Move Flow</h3>
            
            <div class="diagram">
STEP 1: Player clicks board cell
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Defold Client        ‚îÇ
‚îÇ ttt.gui_script       ‚îÇ
‚îÇ on_input (mouse)     ‚îÇ
‚îÇ cell_at(x, y)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
    cell = 4 (center)
         ‚îÇ
         ‚îú‚îÄ HTTP POST /api/move
         ‚îÇ  {
         ‚îÇ    "sessionId": "uuid-123",
         ‚îÇ    "matchId": "M-uuid-abc",
         ‚îÇ    "cellPosition": 4
         ‚îÇ  }
         ‚îÇ
         ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ RestApiServer    ‚îÇ
    ‚îÇ /api/move POST   ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
             ‚ñº
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ GameService    ‚îÇ
      ‚îÇ .makeMove()    ‚îÇ
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
      GAME STATE VALIDATION
               ‚îÇ
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ                      ‚îÇ
    [VALID]            [INVALID]
      ‚îÇ                      ‚îÇ
  Move to cache         Return error
  ‚îú‚îÄ gameCache           ("already occupied",
  ‚îÇ  .makeMove()         "not your turn", etc)
  ‚îÇ
  ‚ñº
gameCache updates in-memory state:
‚îú‚îÄ Update xMask or oMask
‚îú‚îÄ Switch currentPlayer
‚îú‚îÄ Check for win/draw
‚îÇ
‚îú‚îÄ If game continues:
‚îÇ   wsNotifier.notifyGameState()
‚îÇ   ‚îú‚îÄ Send to Player 1: {"t": "game_state", 
‚îÇ   ‚îÇ                     "board": "....X....",
‚îÇ   ‚îÇ                     "current_turn": "O"}
‚îÇ   ‚îî‚îÄ Send to Player 2: same state
‚îÇ
‚îî‚îÄ If game ends:
    ‚îú‚îÄ gameCache.saveCompletedGameToDatabase()
    ‚îÇ  ‚îî‚îÄ Writes to game_matches table
    ‚îÇ
    ‚îî‚îÄ wsNotifier.notifyGameState() with status="finished"
       ‚îú‚îÄ Send to both: {"t": "game_over",
       ‚îÇ               "board": "X..XO.O..",
       ‚îÇ               "result": "X_wins"}
       ‚îî‚îÄ Save stats to player_sessions
            </div>
            
            <h3>3.3 Handling Disconnection & Reconnection</h3>
            
            <div class="diagram">
SCENARIO: Player's internet drops during game

STEP 1: Disconnect Event
Player loses connection
  ‚îÇ
  ‚ñº
WebSocket Server
  ‚îú‚îÄ onClose() fires
  ‚îÇ  ‚îú‚îÄ Find session by connection
  ‚îÇ  ‚îî‚îÄ wsNotifier.unregisterConnection(sessionId)
  ‚îÇ      ‚îî‚îÄ Remove from sessionConnections map
  ‚îÇ      ‚îî‚îÄ Update DB: connection_status = 'disconnected'
  ‚îÇ
  ‚îî‚îÄ If in active game:
     ‚îú‚îÄ Check TttRoom.onLeave()
     ‚îî‚îÄ Start 120-second forfeit timer

STEP 2: Server tries to notify opponent
WebSocketNotifier.sendToSession(sessionId, message)
  ‚îú‚îÄ Check: sessionConnections.get(sessionId)
  ‚îÇ ‚îî‚îÄ Returns null (disconnected)
  ‚îÇ
  ‚îî‚îÄ Call: storePendingNotification()
     ‚îî‚îÄ INSERT INTO pending_notifications table
        (session_id, notification_type, data, next_retry)

STEP 3: Player reconnects
Client reconnects WebSocket
  ‚îÇ
  ‚ñº
Server.onOpen() fires
  ‚îú‚îÄ Client sends new message with sessionId
  ‚îÇ
  ‚ñº
Server.onMessage() ‚Üí registerConnection(sessionId, newConn)
  ‚îÇ
  ‚îú‚îÄ Update sessionConnections[sessionId] = newConn
  ‚îÇ
  ‚îî‚îÄ wsNotifier.sendPendingMessages(sessionId)
     ‚îú‚îÄ Query: SELECT * FROM pending_notifications
     ‚îÇ         WHERE session_id = ? AND delivered = FALSE
     ‚îÇ
     ‚îî‚îÄ For each notification:
        ‚îú‚îÄ Send via new WebSocket connection
        ‚îî‚îÄ Mark as delivered
        
All missed updates are delivered!
            </div>
            
            <!-- ===== THREADING ===== -->
            <h2>4. Threading & Concurrency Model</h2>
            
            <h3>4.1 Thread Pool Architecture</h3>
            
            <div class="code-block"><code>Main Thread:
‚îî‚îÄ Starts all servers and thread pools

WebSocket Server Thread (Netty):
‚îú‚îÄ Listens on port 8080
‚îú‚îÄ Calls onOpen/onMessage/onClose for each client
‚îî‚îÄ Delegates work to GameService thread pool

GameService Thread Pool (ExecutorService):
‚îú‚îÄ Fixed pool of 8 worker threads
‚îú‚îÄ Each joinGame() runs in a separate thread
‚îú‚îÄ Each makeMove() runs in a separate thread
‚îî‚îÄ Prevents blocking the WebSocket thread

DatabaseManager Thread Pool:
‚îú‚îÄ ScheduledExecutorService for cleanup tasks
‚îú‚îÄ Runs connection pool cleanup every 5 minutes
‚îî‚îÄ Runs pending notification retry every 10 seconds

WebSocketNotifier Thread Pools:
‚îú‚îÄ Retry scheduler: Retries failed messages
‚îî‚îÄ Heartbeat scheduler: Sends ping/pong every 30 seconds

TttRoom Thread Pool:
‚îú‚îÄ Timers for 120-second move timeout per room
‚îî‚îÄ Executes onMove() in separate thread</code></div>
            
            <h3>4.2 Concurrency Challenges & Solutions</h3>
            
            <table>
                <tr>
                    <th>Challenge</th>
                    <th>Problem</th>
                    <th>Solution</th>
                    <th>Code</th>
                </tr>
                <tr>
                    <td><strong>Lobby Race</strong></td>
                    <td>Two players call joinGame() simultaneously; both see empty lobby</td>
                    <td><code>synchronized (lobbyLock)</code></td>
                    <td>sync block in GameService.joinGame()</td>
                </tr>
                <tr>
                    <td><strong>Game State Mutations</strong></td>
                    <td>Multiple threads accessing game board</td>
                    <td><code>ConcurrentHashMap</code></td>
                    <td>GameStateCache uses ConcurrentHashMap</td>
                </tr>
                <tr>
                    <td><strong>DB Connection Exhaustion</strong></td>
                    <td>Too many threads opening connections</td>
                    <td>Connection pooling</td>
                    <td>ConnectionPool maintains max 10 connections</td>
                </tr>
                <tr>
                    <td><strong>Message Ordering</strong></td>
                    <td>Messages arrive out of order</td>
                    <td>Timestamping, state versioning</td>
                    <td>state_version field in game_moves table</td>
                </tr>
                <tr>
                    <td><strong>Notification Overflow</strong></td>
                    <td>Messages accumulate for disconnected clients</td>
                    <td>Max 3 retry attempts, exponential backoff</td>
                    <td>pending_notifications with attempts/max_attempts</td>
                </tr>
            </table>
            
            <h3>4.3 CompletableFuture Usage</h3>
            
            <div class="code-block"><code>public CompletableFuture<String> joinGame(String sessionId, String playerName) {
    return CompletableFuture.supplyAsync(() -> {
        // This code runs in GameService thread pool
        synchronized (lobbyLock) {
            // ... game logic ...
            return matchId; // Completes the Future
        }
    }, gameThreadPool);
}

// Called from HTTP request handler:
String matchId = gameService.joinGame(sessionId, playerName).get();</code></div>
            
            <p><strong>Why CompletableFuture?</strong></p>
            <ul>
                <li><strong>Non-blocking REST API:</strong> HTTP request doesn't block entire WebSocket server</li>
                <li><strong>Clean Async Code:</strong> Chains operations with <code>.thenApply()</code>, <code>.exceptionally()</code>, etc.</li>
                <li><strong>Timeout Safety:</strong> Can set timeout with <code>.get(timeout, unit)</code></li>
            </ul>
            
        </div>
        
        <div class="footer">
            <p>Tic-Tac-Toe Server Architecture Documentation | Part 3 of 5</p>
            <p><a href="ARCHITECTURE_BREAKDOWN_Part2.html">‚Üê Part 2</a> | <a href="ARCHITECTURE_BREAKDOWN_Part4.html">Part 4 ‚Üí</a></p>
        </div>
    </div>
</body>
</html>
